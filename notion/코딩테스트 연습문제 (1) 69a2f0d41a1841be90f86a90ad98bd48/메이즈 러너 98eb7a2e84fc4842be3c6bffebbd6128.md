# 메이즈 러너

소유자: 준혁 최
태그: 삼성 SW 역량테스트, 코드트리

> 문제 url : [https://www.codetree.ai/training-field/frequent-problems/problems/maze-runner/description?page=1&pageSize=20](https://www.codetree.ai/training-field/frequent-problems/problems/maze-runner/description?page=1&pageSize=20)
> 

---

- **솔루션 코드**
    
    ```cpp
    #include <iostream>
    #include <vector>
    #include <math.h>
    
    using namespace std;
    
    // modules
    int dir = 0;
    int dx[] = {-1, 0, 1, 0};
    int dy[] = {0, 1, 0, -1};
    
    int N, M, K;
    vector<vector<int>> map;
    vector<vector<int>> user;
    vector<int> pave;
    vector<int> Exit;
    int turns = 0;
    
    bool check_manhattan(int vx, int vy, int x, int y){
        if(x == 0){
            if(vy * y > 0) return true;
            else return false;
        }
        else{
            if(vx * x > 0) return true;
            else return false;
        }
    }
    bool check_wall(int x, int y){
        if(x==-1 || y==-1 || x==N || y==N) return false;
        if(map[x][y] > 0) return false;
        return true;
    }
    
    void moveOne(int &i){
        int vx = Exit[0] - user[i][0];
        int vy = Exit[1] - user[i][1];
        for(int k=0; k<4; ++k){
            int rotated_dir = k;
            bool proper = check_manhattan(vx, vy, dx[rotated_dir], dy[rotated_dir]);
            bool noWall = check_wall(user[i][0] + dx[rotated_dir], user[i][1] + dy[rotated_dir]);
            if(proper && noWall){
                user[i][0] += dx[rotated_dir];
                user[i][1] += dy[rotated_dir];
                ++pave[i];
                //cout<<"Moved : " << i << ") "<< user[i][0] << ","<<user[i][1]<<endl;
                if(user[i][0] == Exit[0] && user[i][1] == Exit[1]){
                    user.erase(user.begin() + i);
                    --i;
                    --M;
                }
                return;
            }
        }
    }
    void move(){
        for(int i=0; i<M; ++i){
            moveOne(i);
        }
    }
    
    vector<int> smallest(int ex, int ey, int ax, int ay, int len){
        int end_x = max(len, max(ex, ax));
        int end_y = max(len, max(ey, ay));
        return {end_x, end_y};
    }
    
    void rotate(){
        int minSquare = N;
        vector<int> end(2,0);
        
        // Area
        for(int i=0; i<M; ++i){
            int len = max(abs(Exit[0] - user[i][0]), abs(Exit[1] - user[i][1]));
            if(len < minSquare) {
                minSquare = len;
                end = smallest(Exit[0], Exit[1], user[i][0], user[i][1], minSquare);
            }
            else if(len == minSquare){
                vector<int> can_end = smallest(Exit[0], Exit[1], user[i][0], user[i][1], minSquare);
    
                if(can_end[0] == end[0] && can_end[1] < end[1]) end = can_end;
                else if(can_end[0] < end[0]) end = can_end;
            }
        }
    
        int sx1, sy1;
        sx1 = end[0] - minSquare;
        sy1 = end[1] - minSquare;
        ++minSquare;
        //
        vector<vector<int>> newArr(minSquare, vector<int>(minSquare));
        for(int i=0; i<minSquare; ++i){
            for(int j=0; j<minSquare; ++j){
                newArr[j][minSquare-1-i] = map[sx1 + i][sy1 + j];
                if(newArr[j][minSquare-1-i] > 0) --newArr[j][minSquare-1-i];
            }
        }
        for(int i=0; i<minSquare; ++i){
            for(int j=0; j<minSquare; ++j){
                map[sx1 + i][sy1 + j] = newArr[i][j];
            }
        }
        //cout<<sx1 <<","<<sy1<<"//"<<minSquare<<endl;
        //*
        for(int i=0; i<M; ++i){
            int rx = user[i][0] - sx1;
            int ry = user[i][1] - sy1;
            if(rx >= 0 && rx < minSquare && ry >= 0 && ry < minSquare){
                user[i][0] = ry + sx1;
                user[i][1] = minSquare - 1 - rx + sy1;
                //cout<<"Rotated : " << i << ") "<<user[i][0]<<", "<<user[i][1]<<endl;
            }
        }
        int tmp_x = Exit[0] - sx1;
        int tmp_y = Exit[1] - sy1;
        Exit[0] = tmp_y + sx1;
        Exit[1] = minSquare - 1 - tmp_x + sy1;
        //cout<<"Rotated Exit : " << ") "<<Exit[0]<<", "<<Exit[1]<<endl;
        //*/
    }
    
    int main() {
        // init
        cin >> N >> M >> K;
        map = vector<vector<int>>(N, vector<int>(N));
        for(int i=0; i<N; ++i){
            for(int j=0; j<N; ++j){
                cin >> map[i][j];
            }
        }
        user = vector<vector<int>>(M, vector<int>(2));
        pave = vector<int>(M, 0);
        for(int i=0; i<M; ++i){
            cin >> user[i][0] >> user[i][1];
        }
        for(int i=0; i<M; ++i){
            --user[i][0]; --user[i][1];
        }
        Exit = vector<int>(2);
        cin >> Exit[0] >> Exit[1];
        --Exit[0]; --Exit[1];
        //
    
        while(K-->0){
            move();
            dir = (dir + 1) % 4;
            if(M==0) break;
            rotate();
        }
        int total = 0;
        for(int i=0 ; i<pave.size(); ++i){
            //cout<<pave[i]<<endl;
            total += pave[i];
        }
        for(int i=0; i<M; ++i){
            //cout <<user[i][0] << "," << user[i][1]<<endl; 
        }
        cout<<total<<endl;
        cout<<Exit[0]+1 <<" "<< Exit[1]+1<<endl;
    
        map.clear();
        user.clear();
        pave.clear();
        Exit.clear();
        return 0;
    }
    ```
    

---

### 문제 분석

- N * N 미로 지도
    - 지도 좌표는 1~N 자연수 좌표 이용
    - 빈 칸 : 0, 모험가 위치 가능
    - 벽 : 1 이상, 회전 시 내구도 -1, 0이 될 경우 빈 칸으로 바뀜
    - 출구 : 도착 즉시 탈출
- 모험가 이동 규칙
    - 좌표 간 거리는 맨해튼 거리 이용
    - 모든 모험가 동시에 움직임
    - 이동은 상하 좌우
    - 출구와 거리가 가까워지는 방향만 가능
    - 움직일 수 있을 경우 상하 방향 우선
    - 움직일 수 없을 경우 stay
    - 같은 좌표에 복수의 모험가 stay 가능
- 이동 후 미로 회전
    - 출구와 **최소 한 명**의 모험가를 포함하는 최소 크기의 정사각형 선택
    - 정사각형은 상단에 있을수록, 좌측에 있을수록 우선 선택
    - 시계 방향 90도로 정사각형 내 모든 좌표값 회전
- **목표**
    - K번의 규칙 이행 후 움직인 거리와 출구의 최종 좌표
    - K번 시행 중 모든 모험가가 탈출 시 정지

---